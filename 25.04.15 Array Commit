import java.util.Scanner;
//java에서 지원하는 클래스에서 Scanner란 클래스를 참조한다

public class Main {
    public static void main(String[] args) {
       int[] arr1;              // int 타입의 배열을 선언
       arr1 = new int [5];      // 동적으로 배열의 크기를 할당

       int[] arr2 = {10,20,30,40,50}; // 위와 똑같은 기능이지만 조금 더 가시성이 증가하는 선언 방법
       
        int[][] arr3;           //2차원 int타입의 배열 선언
        arr3 = new int[2][3];   //2x3 크기의 2차원 배열 선언

       int[][] arr4 = {
        (1, 2 ,3)
        (4, 5 ,6)
        (7, 8, 9)
       };                       //위와 똑같은 기능이지만 리팩토링된 배열

       //일반 for문 
       for(int i = 0; i<arr1.length; i++)
       {
            int number = arr1[i];
            System.out.println(number);
       }

       /*
       향상된 for문
       굳이 처음부터 끝까지 배열을 탐색하는 for문에서는 일반 for문 사용하면 쓸데없는 변수를 생성해줘야하며
       코드의 길이 또한 늘어남 그러나 향상된 for문을 사용하는 경우는 *처음부터 끝까지 읽는 배열* 을 사용할 때 사용하면 좋음
       */
       for(int number : arr1)   
       {
            System.out.println(number);
       }
      
       
       /*
       향상된 for문을 사용 할 수 없는 경우
        for문 내에서 증감하는 index를 사용하는 경우에는 사용할 index가 당연히
        존재하지 않으므로 사용불가 위에서 강조한 내용대로 처음부터 끝까지 다 읽는 for문에서만 사용가능
       */
       for (int i = 0; i<arr1.length; i++)
       {
            System.out.println("arr의 "+i+"번의 결과는"+arr1[i]);
       }

       

    }


    }

    /*
     * java에서 배열 선언문이 왜 저따구인가 봤더니 어제 공부했던 자바의 철학과 또또 관련이 있으시다
     * 어제 입력도 c랑 다르게 객체로 받는다해서 저따구로 선언문이 생긴거였는데 배열도 객체로 하신단다 홀리 씟 
     *
     * java의 배열 구조
     *  ┌──────────────┐
       │   arr        │ ─────┐
       └──────────────┘      ▼
                ┌────────────────────────────┐
                │ int[] 객체 (힙 메모리)     │  ← 배열도 "객체"
                ├────────────────────────────┤
                │ length: 4                  │  ← 객체 속성
                ├────────────────────────────┤
                │ [0] → 0                    │
                │ [1] → 0                    │
                │ [2] → 0                    │
                │ [3] → 0                    │
                └────────────────────────────┘

     * 
     * c에서의 배열 구조
     * ┌────────────────────────────┐
       │ arr[0]  │ arr[1] │ arr[2] │ arr[3] │  ← 전부 스택에 있음
       └────────────────────────────┘

       한마디로 c에서 길이를 구하려면 직접 구해야했는데 .legth로 한번에 되는 이유 또한 java는 배열이 객체라서 그렇다
       java는 c와 다르게 배열 또한 메모리 덩어리가 아니라 객체로 저장하기 때문에 약간 다르며
       c와 다르게 컴파일 타임에서 정적 할당이 불가능하다. 
       
       세줄 요약: 
       배열은 java는 객체 C는 메모리덩어리로 저장한다 
       C는 arr[num1][num2] 이런식으로 선언이 불가능하다 왜냐하면 변수의 크기를 결정하는게 변수니깐 메모리 누수가 일어날 수도 있어서 불가능
       하지만 java는 int[][] arr = new int[num1][num2] 이런식으로 가능 왜냐하면 객체니깐, 메모리 관리를 프로그램이 해주니까 가능 
       


     */

